

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Query Processing &mdash; dbms  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> dbms
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">Frequently Answered Questions for Database Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fall2020/index.html">CSCI 4380 Database Systems - Fall 2020</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fall2020/index.html#indices-and-tables">Indices and tables</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">dbms</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Query Processing</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/spring2018/course_notes/query_processing.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="query-processing">
<h1>Query Processing<a class="headerlink" href="#query-processing" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>SQL queries are converted bag relational algebra queries to be
implemented</p></li>
<li><p>We will investigate how different relational algebra operations are
implemented</p></li>
<li><p>We will see potentially multiple ways to implement each operation</p></li>
<li><p>Overall picture of the DBMS system components is seen below. We are
interested in the query execution component.</p></li>
</ul>
<a class="reference internal image-reference" href="spring2018/course_notes/query_execution_images/Slide01.png"><img alt="spring2018/course_notes/query_execution_images/Slide01.png" class="align-center" src="spring2018/course_notes/query_execution_images/Slide01.png" style="width: 600px;" /></a>
</div>
<div class="section" id="disk-access-process-overly-simplifed">
<h2>Disk Access Process (Overly Simplifed)<a class="headerlink" href="#disk-access-process-overly-simplifed" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>Remember that to process any data, it must be first brought to memory.</p></li>
<li><p>Some DBMS component indicates it wants to read record R</p>
<ul>
<li><p>File Manager:</p>
<p>Does security check</p>
<p>Uses access structures to determine the page it is on</p>
<p>Asks the buffer manager to find that page</p>
</li>
<li><p>Buffer Manager</p>
<p>Checks to see if the page is already in the buffer</p>
<p>If so, gives the buffer address to the requestor</p>
<p>If not, allocates a buffer frame</p>
<p>Asks the Disk Manager to get the page</p>
</li>
<li><p>Disk Manager</p>
<p>Determines the physical address(es) of the page</p>
<p>Asks the disk controller to get the appropriate block of data from
the physical address</p>
<p>Disk controller instructs disk driver to do the dirty job</p>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="cost-and-resources">
<h2>Cost and Resources<a class="headerlink" href="#cost-and-resources" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>An SQL query is translated to a combination of relational algebra
operations.</p></li>
<li><p>Each operation in the query is given some resources: memory blocks
to use for the operation.</p>
<p>We will use M to denote the number of blocks available to a query.</p>
</li>
<li><p>We are interested in the overall cost of a query. We will only
consider total number of disk pages read/written to execute the
query.</p>
<p>We will use PAGES(R) to denote the total number of pages in
relation R.</p>
</li>
<li><p>Note that CPU complexity of a query is going to be disregarded
(i.e. the complexity of the algorithm once the data is in memory)
due to the following reasons:</p>
<ul class="simple">
<li><p>The cost of reading/writing data is much higher than any operation
in memory. So, the donimating cost is disk access.</p></li>
<li><p>We assume each algorithm is implemented as efficiently as possible.</p></li>
<li><p>It may not even be possible to bring all the data for a query in
memory at once, which may result in the data being read multiple
times.</p></li>
</ul>
</li>
<li><p>The cost of a query (total number of pages read and written) depends
on how much memory is available (M). We will see how these two are
related for each operation.</p></li>
</ul>
</div>
<div class="section" id="iterator-interface">
<h2>Iterator Interface<a class="headerlink" href="#iterator-interface" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Each operator in the database is implemented using three main functions:</p>
<ul>
<li><p>open() initializes the necessary memory structures (i.e. M
buffers) and/or streams</p></li>
<li><p>getNext() reads data input streams and processes the data until a
block full of output is produced or the input is completely
processed, puts the output to the output buffer</p></li>
<li><p>close() frees all the structures used by the operator</p></li>
</ul>
</li>
<li><p>Since each operator works the same way, we can chain up the
operators by using the input buffer for an operation as the output
buffer for the operation below.</p>
<ul>
<li><p>If this is the last operation in the query tree, then the output
buffer is simply the standard output to the user executing the
query</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="iterator-example">
<h2>Iterator Example<a class="headerlink" href="#iterator-example" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>Suppose we are processing</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">select</span> <span class="o">*</span> <span class="kn">from</span> <span class="nn">R</span> <span class="n">where</span> <span class="n">C</span>
</pre></div>
</div>
<p>by scanning the relation R.</p>
</li>
<li><p>SCAN(R,C):</p>
<ul class="simple">
<li><p>open() reads the location of the data pages for R and allocates
the necessary memory blocks (at least M=1 block is needed)</p></li>
<li><p>getNext() reads blocks of R, for each tuple, if it satisfies the
condition C, moves it to the output buffer until the output block
is full and then copies the output block to the output stream</p></li>
<li><p>close()  frees all the memory used for this operation.</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="operator-classes">
<h2>Operator classes<a class="headerlink" href="#operator-classes" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>Query operators are classified into classes:</p>
<ul class="simple">
<li><p>One pass</p></li>
<li><p>Two pass</p></li>
<li><p>Multi-pass</p></li>
</ul>
<p>depending on the availability of memory, storage method of the
relation (i.e. sortedness for example) and the number of pages it
occupies on disk.</p>
</li>
</ul>
</div>
<div class="section" id="one-pass-algorithms">
<h2>One pass algorithms<a class="headerlink" href="#one-pass-algorithms" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>The algorithms require one pass over a given relation.</p></li>
<li><p>Note that this depends on the availability of the necessary amount
of memory as explained for each operator.</p></li>
</ul>
</div>
<div class="section" id="duplicate-removal">
<h2>Duplicate removal<a class="headerlink" href="#duplicate-removal" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>Given M pages of memory. Let X be 1 page, and Y be M-1 pages in memory.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Read</span> <span class="n">R</span> <span class="n">into</span> <span class="n">X</span><span class="p">,</span> <span class="mi">1</span> <span class="n">page</span> <span class="n">at</span> <span class="n">a</span> <span class="n">time</span><span class="o">.</span>

<span class="n">For</span> <span class="n">each</span> <span class="nb">tuple</span> <span class="n">t</span><span class="p">,</span> <span class="n">check</span><span class="p">:</span>
   <span class="n">If</span> <span class="nb">tuple</span> <span class="n">t</span> <span class="ow">is</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">:</span>
      <span class="n">it</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">seen</span><span class="p">,</span> <span class="n">remove</span> <span class="n">t</span><span class="o">.</span>
   <span class="n">Else</span>
      <span class="n">insert</span> <span class="n">t</span> <span class="n">into</span> <span class="n">Y</span><span class="o">.</span>
</pre></div>
</div>
</li>
<li><p>getNext() will read a one block from Y and output. The next time it
will be called, we need to process the operation until another block
in Y is filled.</p></li>
<li><p>This is a one-pass operation only if after duplicate removal, R fits
in M-1 blocks.</p></li>
</ul>
</div>
<div class="section" id="group-by">
<h2>Group by<a class="headerlink" href="#group-by" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>Given M pages of memory. Let X be 1 page, and Y be M-1 pages in memory.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">For</span> <span class="n">each</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">,</span> <span class="n">we</span> <span class="n">are</span> <span class="n">going</span> <span class="n">to</span> <span class="n">keep</span><span class="p">:</span>
    <span class="n">the</span> <span class="n">grouping</span> <span class="n">attributes</span>
    <span class="n">the</span> <span class="n">aggregate</span> <span class="n">value</span>
       <span class="k">for</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="nb">sum</span><span class="p">:</span> <span class="n">keep</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span>
       <span class="nb">sum</span> <span class="n">of</span> <span class="n">the</span> <span class="n">tuples</span> <span class="n">seen</span> <span class="n">so</span> <span class="n">far</span>

       <span class="k">for</span> <span class="n">avg</span><span class="p">,</span> <span class="n">keep</span> <span class="n">count</span> <span class="ow">and</span> <span class="nb">sum</span><span class="o">.</span>


<span class="n">Read</span> <span class="n">R</span> <span class="n">into</span> <span class="n">X</span><span class="p">,</span> <span class="mi">1</span> <span class="n">page</span> <span class="n">at</span> <span class="n">a</span> <span class="n">time</span><span class="o">.</span>
<span class="n">For</span> <span class="n">each</span> <span class="nb">tuple</span> <span class="n">t</span><span class="p">,</span> <span class="n">check</span><span class="p">:</span>
    <span class="n">If</span> <span class="n">the</span> <span class="n">corresponding</span> <span class="n">group</span> <span class="k">for</span> <span class="nb">tuple</span> <span class="n">t</span> <span class="ow">is</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">:</span>
         <span class="n">update</span> <span class="n">its</span> <span class="n">aggregates</span><span class="o">.</span>

    <span class="n">Else</span>
          <span class="n">create</span> <span class="n">a</span> <span class="n">new</span> <span class="n">group</span> <span class="k">for</span> <span class="n">t</span> <span class="n">into</span> <span class="n">Y</span> <span class="ow">and</span> <span class="n">initialize</span> <span class="n">its</span> <span class="n">statistics</span><span class="o">.</span>
</pre></div>
</div>
</li>
<li><p>This is possible only if all the results fit in Y (M-1) blocks.  We
cannot output the tuples until we finish processing all of R.</p></li>
</ul>
</div>
<div class="section" id="set-and-bag-operators">
<h2>Set and bag operators<a class="headerlink" href="#set-and-bag-operators" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>Bag Union of R and S:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Read</span> <span class="n">R</span> <span class="n">one</span> <span class="n">block</span> <span class="n">at</span> <span class="n">a</span> <span class="n">time</span> <span class="ow">and</span> <span class="n">output</span>
<span class="n">Read</span> <span class="n">S</span> <span class="n">one</span> <span class="n">block</span> <span class="n">at</span> <span class="n">a</span> <span class="n">time</span> <span class="ow">and</span> <span class="n">output</span>
</pre></div>
</div>
</li>
<li><p>Set Union of R and S:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Read</span> <span class="n">R</span> <span class="ow">and</span> <span class="n">remove</span> <span class="n">duplicates</span>
<span class="n">Read</span> <span class="n">S</span> <span class="n">into</span> <span class="n">the</span> <span class="n">same</span> <span class="n">space</span> <span class="ow">and</span> <span class="k">continue</span> <span class="n">to</span> <span class="n">remove</span> <span class="n">duplicates</span>
</pre></div>
</div>
</li>
<li><p>Set intersection:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Read</span> <span class="n">R</span><span class="p">,</span> <span class="n">remove</span> <span class="n">duplicates</span> <span class="ow">and</span> <span class="n">store</span> <span class="n">into</span> <span class="n">M</span><span class="o">-</span><span class="mi">1</span> <span class="n">blocks</span> <span class="p">(</span><span class="n">section</span> <span class="n">Y</span><span class="p">)</span><span class="o">.</span>
<span class="n">Read</span> <span class="n">S</span><span class="o">.</span>
<span class="n">If</span> <span class="n">the</span> <span class="nb">tuple</span> <span class="ow">is</span> <span class="ow">in</span> <span class="n">Y</span>
      <span class="n">output</span> <span class="ow">and</span> <span class="n">remove</span> <span class="kn">from</span> <span class="nn">Y</span>
<span class="n">Else</span>
      <span class="n">discard</span> <span class="n">the</span> <span class="nb">tuple</span>
</pre></div>
</div>
</li>
<li><p>Bag Intersection:</p>
<p>Bag intersection requires that we keep track of how many copies of
each tuple there are.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Read</span> <span class="n">R</span><span class="p">,</span> <span class="n">group</span> <span class="n">by</span> <span class="nb">all</span> <span class="n">attributes</span> <span class="ow">and</span> <span class="n">add</span> <span class="n">a</span> <span class="n">count</span> <span class="k">for</span> <span class="n">R</span><span class="o">.</span>
<span class="n">Store</span> <span class="n">into</span> <span class="n">M</span><span class="o">-</span><span class="mi">1</span> <span class="n">blocks</span> <span class="p">(</span><span class="n">Y</span> <span class="n">section</span><span class="p">)</span><span class="o">.</span>

<span class="n">Read</span> <span class="n">S</span><span class="p">,</span> <span class="k">for</span> <span class="n">each</span> <span class="nb">tuple</span><span class="p">:</span>
    <span class="n">If</span> <span class="ow">is</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">Y</span> <span class="n">section</span>
         <span class="n">increment</span> <span class="n">the</span> <span class="n">count</span> <span class="k">for</span> <span class="n">S</span>
    <span class="n">Else</span>
         <span class="n">disregard</span>
<span class="n">Output</span> <span class="nb">min</span> <span class="n">of</span> <span class="n">count</span> <span class="n">of</span> <span class="n">R</span> <span class="ow">and</span> <span class="n">S</span><span class="o">.</span>
</pre></div>
</div>
</li>
<li><p>All set/bag operations are defined similarly. In most cases the
algorithm is one pass only if the necessary memory is available.</p></li>
<li><p>In general, the cost of one pass the algorithms is PAGES(R) +
PAGES(S) if R and S are being queried, again assuming memory is
available.</p></li>
</ul>
</div>
<div class="section" id="external-sorting">
<h2>External Sorting<a class="headerlink" href="#external-sorting" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>A large number of operators can be executed by an intermediate
sorting step:</p>
<ul class="simple">
<li><p>DISTINCT</p></li>
<li><p>ORDER BY</p></li>
<li><p>GROUP BY</p></li>
<li><p>UNION/INTERSECTION/DIFFERENCE</p></li>
</ul>
</li>
<li><p>A limited amount of memory is available to the sort operation</p>
<p>M: the number of memory pages available for the sort operation</p>
<p>PAGES(R): total number of disk pages for relation R</p>
</li>
<li><p>If PAGES(R) &lt;= M, then the relation can be sorted in one pass: read
the relation into memory and apply any sorting algorithm. The cost
if PAGES(R) pages.</p></li>
</ul>
</div>
<div class="section" id="multi-step-external-sorting">
<h2>Multi-step external sorting<a class="headerlink" href="#multi-step-external-sorting" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>If PAGES(R) &gt; M, then external sorting must be used.</p>
<p>The sort operation is a two step process:</p>
<ul class="simple">
<li><p>STEP 1: Sort groups of M blocks in memory and write each block to
disk</p></li>
<li><p>STEP 2: Merge the groups in successive steps into a single sorted
relation</p></li>
</ul>
</li>
<li><p>Step 1:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nb">all</span> <span class="n">pages</span> <span class="ow">in</span> <span class="n">relation</span> <span class="n">R</span><span class="p">:</span>
   <span class="n">read</span> <span class="n">data</span> <span class="n">pages</span> <span class="k">for</span> <span class="n">R</span> <span class="n">into</span> <span class="n">M</span> <span class="n">pages</span>
   <span class="n">sor</span> <span class="n">the</span> <span class="n">M</span> <span class="n">pages</span> <span class="ow">in</span> <span class="n">memory</span>
   <span class="n">dump</span> <span class="n">the</span> <span class="nb">sorted</span> <span class="n">file</span> <span class="n">into</span> <span class="n">a</span> <span class="n">temporary</span> <span class="n">storage</span>
</pre></div>
</div>
</li>
<li><p>Cost of Step 1:</p>
<ul>
<li><p>Read the relation once and write it once (in groups of M)</p>
<p>Total cost: 2*PAGES(R)</p>
</li>
</ul>
</li>
<li><p>Step 2 (may need to be repeated multiple times):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Merging</span> <span class="n">M</span> <span class="nb">sorted</span> <span class="n">groups</span> <span class="n">into</span> <span class="n">one</span>

   <span class="n">Read</span> <span class="n">the</span> <span class="n">first</span> <span class="n">block</span> <span class="n">of</span> <span class="n">each</span> <span class="nb">sorted</span> <span class="n">group</span> <span class="n">into</span> <span class="n">a</span> <span class="n">single</span> <span class="n">memory</span>
   <span class="n">buffer</span> <span class="p">(</span><span class="n">M</span> <span class="n">total</span><span class="p">)</span>

   <span class="n">Merge</span> <span class="n">by</span> <span class="n">removing</span> <span class="n">the</span> <span class="n">lowest</span> <span class="n">value</span> <span class="kn">from</span> <span class="nn">all</span> <span class="n">M</span> <span class="n">pages</span> <span class="ow">and</span> <span class="n">put</span> <span class="ow">in</span>
   <span class="n">the</span> <span class="n">output</span> <span class="n">buffer</span><span class="o">.</span>

   <span class="n">If</span> <span class="n">a</span> <span class="n">page</span> <span class="n">becomes</span> <span class="n">empty</span><span class="p">,</span> <span class="n">read</span> <span class="n">the</span> <span class="nb">next</span> <span class="n">block</span> <span class="k">for</span> <span class="n">that</span> <span class="n">page</span>
   <span class="kn">from</span> <span class="nn">disk.</span>

   <span class="n">When</span> <span class="nb">all</span> <span class="n">groups</span> <span class="n">are</span> <span class="n">empty</span><span class="p">,</span> <span class="n">the</span> <span class="n">process</span> <span class="ow">is</span> <span class="n">complete</span><span class="o">.</span>
</pre></div>
</div>
</li>
<li><p>Note that if there are more than M groups to merge, then we cannot
complete the sorting in one merge step. In this case, we need to
write the data on disk.</p>
<p>In this case, use M-1 blocks for merging and 1 block for output.</p>
</li>
</ul>
</div>
<div class="section" id="example-for-external-sort">
<h2>Example for external sort<a class="headerlink" href="#example-for-external-sort" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Suppose R has 6 pages and we only have M=2 for sorting.</p></li>
</ul>
<a class="reference internal image-reference" href="spring2018/course_notes/query_execution_images/Sorting1.png"><img alt="spring2018/course_notes/query_execution_images/Sorting1.png" src="spring2018/course_notes/query_execution_images/Sorting1.png" style="width: 600px;" /></a>
<ul class="simple">
<li><p>In Step 1, we will read 2 pages of R at a time, sort and then write
back to disk:</p></li>
</ul>
<a class="reference internal image-reference" href="spring2018/course_notes/query_execution_images/Sorting2.png"><img alt="spring2018/course_notes/query_execution_images/Sorting2.png" src="spring2018/course_notes/query_execution_images/Sorting2.png" style="width: 200px;" /></a>
<a class="reference internal image-reference" href="spring2018/course_notes/query_execution_images/Sorting3.png"><img alt="spring2018/course_notes/query_execution_images/Sorting3.png" src="spring2018/course_notes/query_execution_images/Sorting3.png" style="width: 200px;" /></a>
<a class="reference internal image-reference" href="spring2018/course_notes/query_execution_images/Sorting4.png"><img alt="spring2018/course_notes/query_execution_images/Sorting4.png" src="spring2018/course_notes/query_execution_images/Sorting4.png" style="width: 200px;" /></a>
<ul class="simple">
<li><p>Total cost of step 1: 2*6=12 pages.</p></li>
<li><p>Step 2: Now assume M=3.</p></li>
</ul>
<a class="reference internal image-reference" href="spring2018/course_notes/query_execution_images/Sorting5.png"><img alt="spring2018/course_notes/query_execution_images/Sorting5.png" src="spring2018/course_notes/query_execution_images/Sorting5.png" style="width: 600px;" /></a>
<ul class="simple">
<li><p>Read one page from each group, continuously delete the smallest
value and put it in the output buffer.</p></li>
</ul>
<a class="reference internal image-reference" href="spring2018/course_notes/query_execution_images/Sorting5.png"><img alt="spring2018/course_notes/query_execution_images/Sorting5.png" src="spring2018/course_notes/query_execution_images/Sorting5.png" style="width: 600px;" /></a>
<ul class="simple">
<li><p>Given we can read one page from each sorted group, we can finish
the sorting in one execution of Step 2.</p></li>
<li><p>Total cost of step 2: 1*6 = 6</p></li>
<li><p>Overall cost (steps 1 and 2):  12+6 = 18</p></li>
</ul>
<a class="reference internal image-reference" href="spring2018/course_notes/query_execution_images/Sorting6.png"><img alt="spring2018/course_notes/query_execution_images/Sorting6.png" src="spring2018/course_notes/query_execution_images/Sorting6.png" style="width: 600px;" /></a>
</div>
<div class="section" id="multi-step-version-of-step-2">
<h2>Multi-step version of Step 2<a class="headerlink" href="#multi-step-version-of-step-2" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>Let us see a different example.</p>
<p>Suppose PAGES(R)=1,000 and M = 11</p>
</li>
<li><p>Step 1: We create 91 sorted groups (total cost 2,000 pages)</p></li>
<li><p>In Step 2, we cannot really merge all 91 groups (since M=11). We
have to sort and write groups.</p>
<p>We can merge 10 groups (and use 1 block for output) at a time.</p>
<p>Reduce: 91 sorted groups to 10 sorted groups</p>
<p>Total cost: 2,000 pages (read once, write once)</p>
</li>
<li><p>We can repeat Step 2 to merge the remaining 10 groups and output the
result.</p>
<p>Total cost: 1,000 pages (read once and output)</p>
</li>
<li><p>Total cost: 5,000 pages.</p></li>
<li><p>For simplicity, we can just disregard the 1 output buffer in our
computations.</p></li>
</ul>
</div>
<div class="section" id="sort-based-duplicate-removal">
<h2>Sort based duplicate removal<a class="headerlink" href="#sort-based-duplicate-removal" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>When a “distinct” projection is needed, we can do the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Sort</span> <span class="n">the</span> <span class="n">relation</span>
<span class="n">Read</span> <span class="n">the</span> <span class="n">relation</span> <span class="ow">in</span> <span class="nb">sorted</span> <span class="n">order</span>
<span class="n">For</span> <span class="n">each</span> <span class="nb">tuple</span><span class="p">:</span>
   <span class="n">If</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">seen</span>
      <span class="n">discard</span>
   <span class="n">Else</span><span class="p">:</span>
      <span class="n">output</span>
</pre></div>
</div>
</li>
<li><p>Need to keep in memory the last seen tuple only, so 1 page is
sufficient for the operation.</p></li>
<li><p>It is possible to combine sort and duplicate removal</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Read</span> <span class="n">the</span> <span class="n">relation</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">,</span> <span class="n">remove</span> <span class="nb">all</span> <span class="n">unwanted</span> <span class="n">attributes</span>

<span class="n">Sort</span> <span class="n">the</span> <span class="n">tuples</span> <span class="ow">in</span> <span class="n">memory</span><span class="p">,</span> <span class="n">remove</span> <span class="n">duplicates</span> <span class="p">(</span><span class="n">distinct</span><span class="p">)</span> <span class="ow">and</span> <span class="n">write</span>
<span class="n">the</span> <span class="nb">sorted</span> <span class="n">group</span> <span class="n">to</span> <span class="n">disk</span>

<span class="n">Read</span> <span class="n">the</span> <span class="nb">sorted</span> <span class="n">group</span> <span class="k">for</span> <span class="n">k</span><span class="o">-</span><span class="n">way</span><span class="o">-</span><span class="n">merge</span><span class="p">,</span> <span class="n">during</span> <span class="n">merge</span> <span class="n">remove</span> <span class="nb">any</span>
<span class="n">additional</span> <span class="n">duplicates</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="sort-based-projection">
<h2>Sort based projection<a class="headerlink" href="#sort-based-projection" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Cost is similar to external sort, but the relation being read in the
second stage is reduced in size by removing unnecessary attributes</p></li>
<li><p>Tuples are smaller (how many attributes are removed?)</p></li>
<li><p>Duplicates are removed (how many duplicates are there?)</p></li>
</ul>
</div>
<div class="section" id="hash-based-projection">
<h2>Hash based projection<a class="headerlink" href="#hash-based-projection" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>To compute “distinct R.A, R.B,…”:</p>
<p>Read all tuples in R and extract the projected attributes</p>
<p>Hash the remaining attributes to buckets 1 … M in memory (and
continuously remove duplicates from buckets in memory)</p>
<p>Whenever a bucket in memory is full, write it to disk</p>
<p>For any bucket that takes up more than one disk page, read it back
from disk to memory and remove duplicates within the bucket.</p>
</li>
<li><p>Example: 2 pages for hashing and 1 page for processing</p></li>
</ul>
<a class="reference internal image-reference" href="spring2018/course_notes/query_execution_images/Hashing1.png"><img alt="spring2018/course_notes/query_execution_images/Hashing1.png" src="spring2018/course_notes/query_execution_images/Hashing1.png" style="width: 600px;" /></a>
<ul class="simple">
<li><p>Read and put values into the two buckets</p></li>
</ul>
<a class="reference internal image-reference" href="spring2018/course_notes/query_execution_images/Hashing2.png"><img alt="spring2018/course_notes/query_execution_images/Hashing2.png" src="spring2018/course_notes/query_execution_images/Hashing2.png" style="width: 600px;" /></a>
<ul class="simple">
<li><p>If the bucket needs to be computed before the query executes, it
needs to be written to disk.</p></li>
</ul>
<a class="reference internal image-reference" href="spring2018/course_notes/query_execution_images/Hashing3.png"><img alt="spring2018/course_notes/query_execution_images/Hashing3.png" src="spring2018/course_notes/query_execution_images/Hashing3.png" style="width: 600px;" /></a>
<ul class="simple">
<li><p>Once hashing is complete, different operations can be mapped to
different buckets and applied independently in each bucket.</p></li>
</ul>
<a class="reference internal image-reference" href="spring2018/course_notes/query_execution_images/Hashing4.png"><img alt="spring2018/course_notes/query_execution_images/Hashing4.png" src="spring2018/course_notes/query_execution_images/Hashing4.png" style="width: 600px;" /></a>
</div>
<div class="section" id="id1">
<h2>Hash based projection<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>The cost:</p>
<p>The relation has to be read once for hashing</p>
<p>If all the buckets after reduction are too large fit in a single
memory block, then the relation will be written once to disk</p>
<p>If all the disk pages in a single bucket will fit in the M available
blocks, then the last step can be performed in one read.</p>
</li>
</ul>
</div>
<div class="section" id="set-operations">
<h2>Set operations<a class="headerlink" href="#set-operations" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>To compute A UNION B (with duplicate removal), we first hash both A
and B together and remove duplicates in each bucket separately.</p></li>
<li><p>To compute A - B, we hash A and B into the same buckets and then
compute A - B to each bucket separately.</p></li>
</ul>
</div>
<div class="section" id="selections">
<h2>Selections<a class="headerlink" href="#selections" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>To compute SELECT FROM R WHERE C</p>
<p>[Table Scan] Read all of R one block at a time and check C. Only
need a single buffer page to read R. Total cost PAGES(R).</p>
<p>[Index Scan] Read the index to check all or part of C, find
qualifying tuples. Read those tuples from disk and return. Total
cost: the cost of index scan + cost of relation scan.</p>
</li>
<li><p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span>  <span class="n">R</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">D</span>    <span class="n">FROM</span> <span class="n">R</span>
<span class="n">WHERE</span> <span class="n">R</span><span class="o">.</span><span class="n">A</span><span class="o">=</span><span class="mi">10</span> <span class="n">AND</span> <span class="n">R</span><span class="o">.</span><span class="n">B</span><span class="o">=</span><span class="mi">5</span> <span class="n">AND</span> <span class="n">R</span><span class="o">.</span><span class="n">C</span><span class="o">&lt;</span><span class="mi">30</span> <span class="p">;</span>
</pre></div>
</div>
<ul>
<li><p>Given index I1 on R.A,R.B such that</p>
<p>I1 has depth 3</p>
<p>I has about k leaf nodes with about k*c tuples in general for any
specific R.A,R.B value (I.e. duplicate tuples)</p>
</li>
<li><p>Finding the tuple identifier of all tuples with R.A=10 AND R.B=5
takes 3 + k disk reads in the average.</p></li>
<li><p>We still need to read the qualifying k*c tuples from disk to check
R.C, and return R.C, R.D</p></li>
<li><p>Given k*c tuples with R.A=10 and R.B=5, how many disk pages for R
need to be read to find all these tuples?</p>
<p>If the relation is not sorted/clustered with respect to R.A, R.B,
then we might end up reading a different page for each single
tuple. The worst case then is k*c disk reads.</p>
<p>If the relation is clustered with respect to R.A,R.B and suppose
each disk page stores about n tuples of R, then we need to read
about k*c/n disk pages.</p>
</li>
<li><p>Given index I2 on R.A,R.B,R.C such that</p>
<p>I has depth 3</p>
<p>I has about k leaf nodes with about k*c tuples in general for any
specific R.A,R.B value (I.e. duplicate tuples)</p>
<p>Find the leaf nodes for R.A=10 AND R.B=5. For these, we scan the
siblings left to right until R.C &gt;= 30. In the worst case 3 + k
nodes are scanned.</p>
<p>Return all the R.C values from the index, no need to read the
relation.</p>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="access-paths">
<h2>Access Paths<a class="headerlink" href="#access-paths" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>Given a query</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">attrs</span> <span class="n">FROM</span> <span class="n">R</span> <span class="n">WHERE</span> <span class="n">C</span>
</pre></div>
</div>
<p>the following are the possible access paths for this relation</p>
</li>
<li><p>Table scan: Always possible.</p></li>
<li><p>Hash index: Possible if the hash index is on a subset of attributes
A1,…,An such that all conditions in C for A1,…,An are for equality
and are conjunctive (ANDed).</p></li>
<li><p>B-tree index with search key A1,…,Am such that a prefix A1,…,An
of A1,…,Am have equality conditions in C.</p></li>
<li><p>After an index scan, it is necessary to scan the relation if</p>
<ul class="simple">
<li><p>C contains conditions on attributes that are not in the index, or</p></li>
<li><p>Projection attributes are not all in the index</p></li>
</ul>
</li>
<li><p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FROM</span> <span class="n">R</span> <span class="n">WHERE</span> <span class="n">R</span><span class="o">.</span><span class="n">A</span><span class="o">=</span><span class="mi">10</span> <span class="n">AND</span> <span class="n">R</span><span class="o">.</span><span class="n">B</span><span class="o">&lt;</span><span class="mi">10</span> <span class="n">AND</span> <span class="n">R</span><span class="o">.</span><span class="n">C</span> <span class="o">&gt;</span> <span class="mi">20</span>
</pre></div>
</div>
</li>
<li><p>Can we use B-tree indices on</p>
<p>I1 on R(A,B) ?</p>
<p>I2 on R(B,C) ?</p>
<p>I3 on R(D,A) ?</p>
</li>
</ul>
</div>
<div class="section" id="complex-conditions">
<h2>Complex Conditions<a class="headerlink" href="#complex-conditions" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>Given an index can be used to evaluate the selection condition only
partially, how can we compute complex conditions?</p>
<p>FROM R WHERE C1 AND C2</p>
</li>
<li><p>Use index to find tuples that satisfy C1, read tuples from disk and
check C2 in memory.</p></li>
<li><p>Use two indices to find tuples that satisfy C1 and C2 separately,
take the intersection of the tuple identifiers.</p></li>
<li><p>Given multiple indices to evaluate part of a complex query condition
C, which one to choose?</p></li>
<li><p>Choose the most selective one.</p></li>
<li><p>If the resulting tuples can be reduced significantly by another
index, use the next most selective index.</p></li>
<li><p>Otherwise, do a table scan.</p></li>
</ul>
</div>
<div class="section" id="nested-loop-join">
<h2>Nested loop join<a class="headerlink" href="#nested-loop-join" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>The naïve approach R join S (R outer, S inner)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">For</span> <span class="n">each</span> <span class="n">one</span> <span class="n">page</span> <span class="n">of</span> <span class="n">the</span> <span class="n">outer</span> <span class="n">relation</span> <span class="p">(</span><span class="n">R</span><span class="p">):</span>
     <span class="n">read</span> <span class="n">the</span> <span class="n">page</span> <span class="n">into</span> <span class="mi">1</span> <span class="n">block</span> <span class="n">of</span> <span class="n">memory</span>
     <span class="k">for</span> <span class="nb">all</span> <span class="n">pages</span> <span class="n">of</span> <span class="n">the</span> <span class="n">inner</span> <span class="n">relation</span> <span class="p">(</span><span class="n">S</span><span class="p">):</span>
         <span class="n">read</span> <span class="n">the</span> <span class="n">page</span> <span class="n">into</span> <span class="mi">1</span> <span class="n">block</span> <span class="n">of</span> <span class="n">memory</span>
         <span class="n">join</span> <span class="k">with</span> <span class="n">the</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">memory</span>
</pre></div>
</div>
</li>
<li><p>Needs only 2 blocks of memory</p></li>
<li><p>For each block of R, S is read once.</p>
<p>S is read a total of PAGES(R) times, total blocks of S read is then
PAGES(R)*PAGES(S)</p>
<p>R is read once, therefore the total cost is PAGES(R)+PAGES(R)*PAGES(S)</p>
</li>
</ul>
</div>
<div class="section" id="block-nested-loop-join">
<h2>Block nested loop join<a class="headerlink" href="#block-nested-loop-join" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>Given M buffer pages for the query</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">each</span> <span class="n">M</span><span class="o">-</span><span class="mi">1</span> <span class="n">block</span> <span class="n">chunks</span> <span class="n">of</span> <span class="n">outer</span> <span class="n">relation</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
   <span class="n">read</span> <span class="n">M</span><span class="o">-</span><span class="mi">1</span> <span class="n">pages</span> <span class="n">R</span> <span class="n">into</span> <span class="n">memory</span>
   <span class="k">for</span> <span class="n">each</span> <span class="n">page</span> <span class="n">of</span> <span class="n">inner</span> <span class="n">relation</span> <span class="p">(</span><span class="n">S</span><span class="p">)</span>
       <span class="n">read</span> <span class="n">the</span> <span class="n">page</span> <span class="n">into</span> <span class="mi">1</span> <span class="n">memory</span> <span class="n">block</span>
           <span class="n">join</span> <span class="n">the</span> <span class="n">tuples</span> <span class="ow">in</span> <span class="n">S</span> <span class="k">with</span> <span class="nb">all</span> <span class="n">pagse</span> <span class="n">of</span> <span class="n">R</span> <span class="ow">in</span> <span class="n">memory</span>
</pre></div>
</div>
</li>
<li><p>S is read a total of ceiling(PAGES(R)/(M-1)) times,
total I/O cost of S is then PAGES (S)* ceiling(PAGES(R)/(M-1))</p></li>
<li><p>As always, R is read once. So, the total cost is</p>
<p>PAGES(R) + PAGES(S)* ceiling(PAGES(R)/(M-1))</p>
</li>
</ul>
</div>
<div class="section" id="index-nested-loop-join">
<h2>Index nested loop join<a class="headerlink" href="#index-nested-loop-join" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>Index loop join assumes a look-up of matching tuples for S using
an index.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Given</span> <span class="n">R</span> <span class="n">join</span> <span class="n">S</span> <span class="n">on</span> <span class="n">R</span><span class="o">.</span><span class="n">A</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">A</span>

<span class="n">Read</span> <span class="n">R</span> <span class="n">one</span> <span class="n">block</span> <span class="n">at</span> <span class="n">a</span> <span class="n">time</span>
   <span class="n">For</span> <span class="n">each</span> <span class="n">tuples</span> <span class="n">r</span> <span class="n">of</span> <span class="n">R</span>
      <span class="n">Use</span> <span class="n">index</span> <span class="n">on</span> <span class="n">S</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="n">to</span> <span class="n">find</span> <span class="nb">all</span> <span class="n">matching</span> <span class="n">tuples</span>
      <span class="n">Read</span> <span class="n">the</span> <span class="n">tuples</span> <span class="kn">from</span> <span class="nn">disk</span> <span class="ow">and</span> <span class="n">join</span> <span class="k">with</span>
</pre></div>
</div>
</li>
<li><p>If R is not sorted on A, then we might end up reading the same
tuples of S many times</p>
<ul>
<li><p>What if A is R’s primary key?</p>
<p>Then, for each A value, we will look up S only once</p>
</li>
</ul>
</li>
<li><p>Cost:</p>
<ul>
<li><p>The outer relation R is read once, PAGES(R)</p></li>
<li><p>Assume for every tuple r in R, there are about c tuples in S that
would join with R (ideal case is c is very small or 0 most of the
time)</p></li>
<li><p>Then, for each tuples in R:
- We find the matching tuples in S (cost is index look-up, in the</p>
<blockquote>
<div><p>best case one tuple for each level, so h+1 for an index with h
levels)</p>
</div></blockquote>
<ul class="simple">
<li><p>Then, if we need attributes that are not in the join,
we read c tuples from S (which can be in c pages in the worst case)</p></li>
<li><p>Total cost is between PAGES(R) + TUPLES(R) * (h+1) (if no tuples
match or index only scan is fine) and PAGES(R) + TUPLES(R) *
(h+1+c)</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">S</span><span class="o">.</span><span class="n">B</span> <span class="n">FROM</span> <span class="n">R</span><span class="p">,</span><span class="n">S</span> <span class="n">WHERE</span> <span class="n">R</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">B</span>

<span class="n">Index</span> <span class="n">I1</span> <span class="n">on</span> <span class="n">S</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="k">with</span> <span class="mi">2</span> <span class="n">levels</span> <span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">internal</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span>
<span class="n">PAGES</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">TUPLES</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">=</span> <span class="mi">2000</span>
<span class="n">PAGES</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">TUPLES</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">=</span> <span class="mi">4000</span>

<span class="n">Cost</span> <span class="o">=</span> <span class="mi">100</span> <span class="p">(</span><span class="k">for</span> <span class="n">reading</span> <span class="n">R</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2000</span><span class="o">*</span><span class="mi">3</span> <span class="p">(</span><span class="n">index</span> <span class="n">look</span> <span class="n">up</span> <span class="k">for</span> <span class="n">each</span> <span class="nb">tuple</span> <span class="n">of</span> <span class="n">R</span><span class="p">)</span>

<span class="n">SELECT</span> <span class="n">S</span><span class="o">.</span><span class="n">C</span>  <span class="n">FROM</span> <span class="n">R</span><span class="p">,</span><span class="n">S</span> <span class="n">WHERE</span> <span class="n">R</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">B</span>

<span class="n">Assume</span> <span class="n">statistics</span> <span class="n">are</span> <span class="n">same</span> <span class="k">as</span> <span class="n">above</span><span class="p">,</span> <span class="n">but</span> <span class="n">we</span> <span class="n">now</span> <span class="n">need</span> <span class="n">to</span> <span class="n">reach</span>
<span class="n">each</span> <span class="n">matching</span> <span class="nb">tuple</span> <span class="p">(</span><span class="n">at</span> <span class="n">most</span> <span class="mi">4000</span> <span class="n">tuples</span> <span class="n">will</span> <span class="n">match</span><span class="p">)</span>

<span class="n">Cost</span> <span class="o">=</span> <span class="mi">100</span><span class="o">+</span><span class="mi">2000</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">4000</span> <span class="p">(</span><span class="n">one</span> <span class="n">page</span> <span class="n">read</span> <span class="k">for</span> <span class="n">each</span> <span class="n">matched</span> <span class="nb">tuple</span><span class="p">)</span>
</pre></div>
</div>
<p>How could this be, there are only 200 pages of S?</p>
<p>Well, if we are not finding all pages that we need to read first and
reading each page as we find a match, we may end up reading the
pages for S multiple times.</p>
<p>Of course, in reality, you will likely do a lot of reduction of
duplicate page requests in memory and improve on this. This is the
worst case scenario.</p>
<p>Will we ever do this?</p>
<p>No, we will choose not to use index join for this case, clearly it
looks very expensive and we better do some other operation.</p>
</li>
<li><p>Another example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">S</span><span class="o">.</span><span class="n">B</span> <span class="n">FROM</span> <span class="n">R</span><span class="p">,</span><span class="n">S</span> <span class="n">WHERE</span> <span class="n">R</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">B</span> <span class="n">AND</span> <span class="n">R</span><span class="o">.</span><span class="n">B</span><span class="o">=</span><span class="mi">100</span>

<span class="n">Index</span> <span class="n">I1</span> <span class="n">on</span> <span class="n">S</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="k">with</span> <span class="mi">2</span> <span class="n">levels</span> <span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">internal</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span>
<span class="n">PAGES</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">TUPLES</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">=</span> <span class="mi">2000</span>
<span class="n">PAGES</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">TUPLES</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">=</span> <span class="mi">4000</span>
<span class="n">Suppose</span> <span class="n">only</span> <span class="mi">3</span> <span class="n">tuples</span> <span class="n">match</span> <span class="n">R</span><span class="o">.</span><span class="n">B</span><span class="o">=</span><span class="mi">100</span>

<span class="n">So</span><span class="p">,</span> <span class="n">we</span> <span class="n">can</span><span class="p">:</span>
   <span class="n">Scan</span> <span class="nb">all</span> <span class="n">of</span> <span class="n">R</span> <span class="n">to</span> <span class="n">find</span> <span class="n">these</span> <span class="mi">3</span> <span class="n">tuples</span> <span class="p">(</span><span class="mi">100</span> <span class="n">pages</span><span class="p">)</span>
   <span class="n">Read</span> <span class="n">matching</span> <span class="n">tuples</span> <span class="kn">from</span> <span class="nn">S</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
   <span class="n">Total</span> <span class="n">cost</span> <span class="o">=</span> <span class="mi">109</span> <span class="p">(</span><span class="n">using</span> <span class="n">only</span> <span class="mi">2</span> <span class="n">pages</span> <span class="n">of</span> <span class="n">memory</span><span class="p">)</span>

   <span class="n">This</span> <span class="n">would</span> <span class="n">cost</span> <span class="n">a</span> <span class="n">lot</span> <span class="n">more</span> <span class="ow">in</span> <span class="n">block</span><span class="o">-</span><span class="n">nested</span> <span class="n">loop</span> <span class="n">join</span>
   <span class="k">with</span> <span class="n">M</span><span class="o">=</span><span class="mi">2</span> <span class="p">(</span><span class="mi">200</span> <span class="n">pages</span><span class="p">)</span><span class="o">.</span> <span class="n">So</span><span class="p">,</span> <span class="n">index</span> <span class="n">join</span> <span class="ow">is</span> <span class="k">for</span> <span class="n">cases</span>
   <span class="n">where</span> <span class="n">the</span> <span class="n">outer</span> <span class="n">relation</span> <span class="ow">is</span> <span class="n">very</span> <span class="n">small</span> <span class="p">(</span><span class="n">normally</span> <span class="n">after</span>
   <span class="n">a</span> <span class="n">selection</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="sort-merge-join">
<h2>Sort-merge join<a class="headerlink" href="#sort-merge-join" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>Sort both R and S first</p></li>
<li><p>Read R and S one block at a time, and join the matching tuples.</p></li>
<li><p>Sort merge is similar to Step 2 of the sorting algorithm.</p></li>
<li><p>Sort-merge join</p></li>
<li><p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>    <span class="n">S</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="n">Read</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="n">first</span><span class="p">,</span> <span class="n">join</span> <span class="mf">1.</span>
<span class="n">Read</span> <span class="n">the</span> <span class="nb">next</span> <span class="n">block</span> <span class="n">of</span> <span class="n">R</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span> <span class="n">Join</span> <span class="mi">5</span>
<span class="n">Read</span> <span class="n">the</span> <span class="nb">next</span> <span class="n">block</span> <span class="n">of</span> <span class="n">S</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span><span class="o">.</span> <span class="n">No</span> <span class="n">more</span> <span class="n">tuples</span><span class="p">,</span> <span class="n">done</span><span class="o">.</span>
</pre></div>
</div>
</li>
<li><p>If each joining attribute has unique values in R and S, then the
join can be performed in a single step without reading each relation
once forward, PAGES(R) + PAGES(S) + the cost of sort</p></li>
<li><p>If there are duplicate values, then we must worry about if all the
duplicate values from both relations will fit in memory</p></li>
<li><p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">S</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>We need a total of 15 buffer pages to be able to compute this join
at one step.</p></li>
<li><p>In general, a block-nested loop join is performed for duplicate values.</p></li>
</ul>
</div>
<div class="section" id="hash-join">
<h2>Hash join<a class="headerlink" href="#hash-join" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>Hash both R and S on the joining attribute, read R and S once:</p>
<p>PAGES(R) + PAGES(S)</p>
</li>
<li><p>Each bucket will contain both tuples of R and S</p></li>
<li><p>Read each bucket into memory to perform the join within the bucket</p></li>
<li><p>If a bucket cannot fit in memory, then other methods should be used
to perform the join operation within the bucket</p></li>
</ul>
</div>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Sorting and hashing are two main methods that can be used to
implement other operators.</p></li>
<li><p>In particular, sorting may help reduce the cost of multiple
operations upstream</p></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, sibel

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>